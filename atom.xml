<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>威无涯</title>
  
  <subtitle>学无止境</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hellojw.github.io/"/>
  <updated>2019-07-25T08:25:00.493Z</updated>
  <id>https://hellojw.github.io/</id>
  
  <author>
    <name>Jiang Wei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>章节二Go语言基础</title>
    <link href="https://hellojw.github.io/2019/07/03/zhang-jie-er-go-yu-yan-ji-chu-zhi-bu-fen-yi/"/>
    <id>https://hellojw.github.io/2019/07/03/zhang-jie-er-go-yu-yan-ji-chu-zhi-bu-fen-yi/</id>
    <published>2019-07-03T10:19:52.000Z</published>
    <updated>2019-07-25T08:25:00.493Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li><p>编译速度非常快，比C语言编译快</p></li><li><p>二十五个关键字有：</p><pre><code>break      default       func       interface       selectcase       defer         go         map             structchan       else          goto       package         switchconst      fallthrough   if         range           typecontinue   for           import     return          var</code></pre><h3 id="Hello-word-是怎么跑起来的"><a href="#Hello-word-是怎么跑起来的" class="headerlink" title="Hello word 是怎么跑起来的"></a>Hello word 是怎么跑起来的</h3></li></ul><pre><code>package mainimport &quot;fmt&quot;func main(){    fmt.Printf(&quot;Hello,JiangWei&quot;)}</code></pre><ul><li><p>go 是通过package来组织的，后面跟对应的函数名（包名）</p></li><li><p>package中的main是可以独立运行的包，编译后会产生可执行文件</p></li><li><p>非main包，编译后都会产生*.a文件，一般存放在在$GOPATH/pkg下</p></li><li><p>每一个可独立运行的Go程序，必定包含一个package main，且必定包含一个主函数main（入口函数），这个Hello world中的mai’n函数无参数无返回值</p></li><li><p>import “fmt”，引入了fmt包，fmt包里定义了函数Printf，<pkgname>.<funcname>【fmt.Printf】的调用方式，和 Python 十分类似</funcname></pkgname></p></li><li><p>Go package 和 Python 中的 package  类似，利于模块化和可重用性</p><ul><li>模块化：把程序拆分成多个模块</li><li>可重用性：每个模块都能被其他应用程序反复使用</li></ul></li><li><p>Go 支持UTF-8，任何字符都可直接输出，甚至可以用UTF-8中的任何字符作为标识符 ，UTF-8的发明者也是Go 的发明者</p></li></ul><h2 id="Go-基础"><a href="#Go-基础" class="headerlink" title="Go 基础"></a>Go 基础</h2><h3 id="Go-定义变量"><a href="#Go-定义变量" class="headerlink" title="Go 定义变量"></a>Go 定义变量</h3><ul><li><p>最基本的定义变量的方式：【使用 var 关键字，定义全局变量】</p><pre><code>var  variableName  type   //定义一个名称为&quot;variableName&quot;,类型为&quot;type&quot;的变量var  vname1,vname2,vanme3 type //定义多个变量，三个类型为&quot;type&quot;的变量var  variableName type=value  //定义一个变量并初始化值var  vname1,vname2,vname3 type=v1,v2,v3 //定义多个变量并初始化对应的值var  vname1,vname2,vname3 = v1,v2,v3 //忽略声明类型，定义多个变量并初始化对应的值vname1,vname2,vname3: = v1,v2,v3 //:=取代了var和type，简短声明，定义多个变量并初始化对应的值，但是该方法只能用在函数内部，否则在函数外部使用则无法编译</code></pre></li><li><p>_(下划线)是个特殊的变量名，任何赋予它的值都会被丢弃</p><pre><code>_,b:=34,35 //将值赋予给变量，同时丢弃34</code></pre></li><li><p>对于已声明但未使用的变量，在编译阶段会报错</p><pre><code>package mainfunc main(){    var i int}//上述代码会因为声明了i但未使用而编译报错</code></pre></li></ul><h3 id="Go-常量"><a href="#Go-常量" class="headerlink" title="Go 常量"></a>Go 常量</h3><ul><li><p>含义：程序编译阶段就确定下来的值，程序在运行时无法改变该值</p></li><li><p>常量类型：数值、布尔值或字符串等</p></li><li><p>语法如下：</p><pre><code>const  constantName = value</code></pre></li><li><p>常量声明的例子：</p><pre><code>const Pi float32 = 3.1414926  // 明确指定常量的类型const Pi = 3.1415926const i = 1000 constMaxThread = 10 constprefix = &quot;astaxie_&quot;</code></pre></li></ul><h3 id="内置基础类型"><a href="#内置基础类型" class="headerlink" title="内置基础类型"></a>内置基础类型</h3><h4 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h4><ul><li><p>布尔值的类型为bool，值是true或false，默认是false</p><pre><code>var  isActive bool  //全局变量声明var  enabled,disabled = true,false //忽略类型的声明func test() {    var available bool  //一般声明    valid := false      //简短声明    available = true   //赋值操作    }</code></pre></li></ul><h4 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h4><ul><li><p>包括：整数、浮点数、复数</p></li><li><p>整数类型分：无符号和带符号</p><ul><li><p>Go 同时支持 int 和 uint，这两种类型的长度相同</p><ul><li>书中不太理解的话：当前 gcc 和 gccgo 编译器在 32 位和 64 位平台上都使用 32 位来表示 int 和 uint，但未来在 64 位平台上可能增加到 64 位</li></ul></li><li><p>Go 里面也有直接定义好位数的类型：rune,int8,int16,int32,int64 和 byte,unit8，uint16，uint32，unit64</p><ul><li>rune 是 int32 的别称，byte 是 uint8 的别称</li></ul></li><li><p>这些类型的变量之间不允许相互赋值或操作，否则在编译时会引起报错</p><pre><code>var a int8    var b int32c:= a + b以上，int8 和 int32 不可以互用</code></pre></li></ul></li><li><p>浮点数类型有 float32 和 float64，默认是 float64，没有 float 类型</p></li><li><p>复数，默认类型是complex128 ( 64 位实数 + 64 位虚数)</p><ul><li><p>也有complex64 ( 32 位实数 + 32 位虚数)</p></li><li><p>复数的形式为 RE + IMi，其中RE是实数部分，IM是虚数部分，i是虚数单位</p><pre><code>var  c  complex64 = 5+5ifmt.Printf(&quot;Value is: %v&quot;,c)  //output:(5+5i)</code></pre></li></ul></li></ul><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul><li><p>Go 中的字符串都是采用 UTF-8 字符集编码</p></li><li><p>字符串是用一对双引号（“”）或反引号（``）括起来定义的，类型是string</p><pre><code>var frenchHello string   //声明变量为字符串的一般方法var  emptyString string = &quot;&quot;  //声明了一个字符串变量，初始化为空字符串func test() {    no,yes,maybe := &quot;no&quot;,&quot;yes&quot;,&quot;maybe&quot; //简短声明多个变量    frenchHello = &quot;Bonjour&quot;  // 赋值}</code></pre></li><li><p>转换修改字符串值</p><pre><code>var s string = &quot;hello&quot; s[0] = &#39;c&#39;  //代码编译时会报错，因为Go中字符串不可变，此处变更了字符串</code></pre><p>转换修改如下：</p><pre><code>s := &quot;hello&quot;c := []byte(s) //将字符串 s 转换为 []byte 类型c[0] = &#39;c&#39;  s2 := string(c) // 再转换回 string 类型fmt.Printf(&quot;%s\n&quot;,s2)</code></pre></li><li><p>连接两个字符串（也能达到修改字符串的效果）</p><pre><code>s := &quot;hello,&quot; m := &quot;World&quot;a := s + m  //使用 + 操作符来连接两个字符串fmt.Printf(&quot;%s\n&quot;,a)</code></pre><pre><code>切片操作修改字符串：s := &quot;hello&quot;s = &quot;c&quot; + s[1:] fmt.Printf(&quot;%s\n&quot;,s)</code></pre></li><li><p>通过`声明多行字符串</p><pre><code>m := ` helloworld `</code></pre><p>`括起的字符串为 Raw 字符串，即字符串再代码中的形式就是打印时的形式，它没有字符转义，换行也将原样输出</p></li></ul><h4 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h4><ul><li><p>error 类型专门用来处理错误信息，Go 的 package 里有个 error 包专门来处理错误：</p><pre><code>err := errors.New(&quot;emit macho dwarf: elf header corrupted&quot;)if err !=nil{    fmt.Printf(err)}</code></pre></li></ul><h3 id="Go-数据底层的存储"><a href="#Go-数据底层的存储" class="headerlink" title="Go 数据底层的存储"></a>Go 数据底层的存储</h3><ul><li>Go 数据格式的存储：<a href="https://research.swtch.com/godata" target="_blank" rel="noopener">https://research.swtch.com/godata</a> （介绍 Go 数据结构）</li><li>这些基础类型都是分配了一块内存，然后存储了相应的值</li></ul><h3 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h3><h4 id="分组声明"><a href="#分组声明" class="headerlink" title="分组声明"></a>分组声明</h4><ul><li><p>声明多个常量、变量或导入多个包时，可采用分组的方式进行声明</p><pre><code>import &quot;fmt&quot; import &quot;os&quot;const i = 100 constpi = 3.1415 constprefix = &quot;Go_&quot;var i int var pifloat32 varprefix string</code></pre><p>上述代码可分组写成如下形式：</p><pre><code>import( &quot;fmt&quot;  &quot;os&quot;)const( i=100 pi=3.1415 prefix=&quot;Go_&quot;)var( i int     pi float32     prefix string)</code></pre></li><li><p>除非被显式设置为其他值或iota，否则每个const分组的第一个常量被默认设置为它的0值，第二及后续的常量被默认设置为它前面那个常量的值，如果前面那个常量的值为iota，则它被设置为iota</p></li></ul><h4 id="iota-枚举"><a href="#iota-枚举" class="headerlink" title="iota 枚举"></a>iota 枚举</h4><ul><li><p>iota 作为 go 二十五个关键字之一，用来声明 enum，它默认开始值是0，每调用一次加1：</p><pre><code>const( x = iota  // x==0       y = iota  // y==1       z = iota  // z==2       w         // w==3 常量声明省略值时，默认和之前的一个值相同，即此处隐式地说w=iota)const v = iota   // 每遇到一个 const 关键字，iota就会重置，此时 v==0</code></pre></li></ul><h4 id="Go-程序设计的一些规则"><a href="#Go-程序设计的一些规则" class="headerlink" title="Go 程序设计的一些规则"></a>Go 程序设计的一些规则</h4><ul><li>大写字母开头的变量是可导出的，也是其他包可读取的，是公用变量</li><li>小写字母开头的就是不可导出的，是私有变量</li><li>大写字母开头的函数相当于 class 中的带有 public 关键字的公有函数</li><li>小写字母开头的就是有 private 关键字的私有函数</li><li><u><strong>【还需要好好理解上面四句话，不是很深刻】</strong></u></li></ul><h4 id="array-、slice-、map"><a href="#array-、slice-、map" class="headerlink" title="array 、slice 、map"></a>array 、slice 、map</h4><ul><li><p>array</p><ul><li><p>array 就是数组，定义方式：</p><pre><code>var arr [n]type //其中 n 表示数组的长度，type 表示存储元素的类型</code></pre></li><li><p>通过 [] 进行对数据的读取或赋值：</p><pre><code>var arr [10]int  //声明了一个 int 类型的数组arr[0] = 42      //数组下标是从 0 开始的，同时赋值arr[1] = 13      //对下标 1 进行赋值操作fmt.Printf(&quot;The first element is %d\n&quot;,arr[0])  //获取数据，返回42fmt.Printf(&quot;The last  element is %d\n&quot;,arr[9])  //返回未赋值的最后一个元素，默认返回0</code></pre></li><li><p>长度是数组类型的一部分，数组不能改变长度</p></li><li><p>数组之间的赋值是值得赋值，即当把一个数组作为参数传入函数时，传入得其实是该数组的副本，非指针</p></li><li><p>数组可以用 := 来声明</p><pre><code>a := [3]int{1,2,3} //声明了一个长度为 3 的 int 数组b := [10]int{1,2,3} //声明了一个长度为 10 的 int 数组，前三个元素初始化为1，2，3，其他为 0c := [...]int{4,5,6} // ...表示省略长度，Go 会自动根据元素个数来计算长度</code></pre></li><li><p>Go 支持嵌套数组，即多维数组</p><pre><code>//声明了一个二维数组，该数组以两个数组作为元素，其中每个数组中又有 4 个 int 类型的元素doubleArray := [2][4]int{[4]int{1,2,3,4},[4]int{5,6,7,8}}//若内部元素和外部的一样，那上面的声明可以简化，直接忽略内部的类型easyArray := [2][4]int{{1,2,3,4},{5,6,7,8}}</code></pre></li></ul></li><li><p>slice</p><ul><li><p>很多应用场景中，我们需要“动态数组”，在Go中这种数据结构叫 slice</p></li><li><p>slice 并不是真正意义上的动态数组，而是一个引用类型</p></li><li><p>slice 总是指向一个底层 array，slice 的声明也可以同 array 一样，只是不需要长度</p><pre><code>var fslice []int   //和声明 array 一样，只是少了长度slice := []byte {&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;} //声明一个 slice 并初始化数据</code></pre></li><li><p>slice 可以从一个数组或已经存在的 slice 中再次声明</p></li><li><p>slice 通过 array[i:j] 来获取，其中 i 是数组的开始位置，j 是结束位置，但不包含 array[j]，长度是 j-i</p><pre><code>//声明含有10个元素类型为type的数组var ar = [10]byte {&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;,&#39;i&#39;,&#39;j&#39;} var   a, b []byte   //声明两个含有byte的slicea = ar[2:5]         //a指向数组的第3个元素开始，并到第五个元素结束，即ar[2],ar[3],ar[4]b = ar[3:5]         //b 含有的元素是 ar[3],ar[4]</code></pre></li><li><p>slice 和 数组在声明时的区别：</p><ul><li>声明数组时，方括号内写明了数组的长度或使用…自动计算长度</li><li>声明 slice 时，方括号内没有任何字符</li></ul></li><li><p>slice 和 array 的对应关系图【没怎么看懂这种对应关系图】</p></li><li><p>slice 的简单操作：</p><ul><li>slice 的默认开始位置是 0 , ar[:n] 等价于 ar[0:n] ,slice 的第二个序列默认是数组的长度，                     ar[n:] 等价于 ar[0:len(ar)]</li><li>从一个数组里面直接获取 slice，可以这样 ar[:]，因为默认第一个序列为 0 ，第二个是数组的长度，即等价于 ar[0:len(ar)]</li></ul></li><li><p>slice 的更多操作：</p><pre><code>var arry = [10]byte{&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;} //声明一个数组var aSlice, bSlice []byte     //声明两个 slice</code></pre><p>以下是简单操作：</p><pre><code>aSlice = array[:3] 等价于 aSlice = array[0:3], aSlice 包含 a,b,c 元素aSlice = array[5:] 等价于 aSlice = array[5:10], aSlice 包含 f,g,h,i,j 元素aSlice = array[:]  等价于 aSlice = array[0:10], aSlice 包含全部元素</code></pre><p>以下是从 slice 中获取 slice 的操作：</p><pre><code>aSlice = array[3:7]   //aSlice 包含 d,e,f,g 元素, len=4, cap=7bSlice = aSlice[1:3]  //bSlice 包含 aSlice[1],aSlice[2],即含有 e,f 元素bSlice = aSlice[:3]   //bSlice 包含 aSlice[0],aSlice[1],aSlice[2],即含有 d,e,f 元素bSlice = aSlice[0:5]  //对 slice 的 slice 可以在 cap 范围内扩展，bSlice 含有 d,e,f,g,hbSlice = aSlice[:]    //bSlice 包含所有 aSlice 的元素：d,e,f,g</code></pre></li><li><p>slice 是引用类型，当引用改变其中元素的值时，其他所有的引用都会改变该值</p></li><li><p>从概念上来讲：slice像一个结构体，这个结构体包含三个元素：</p><ul><li>指针，指向数组中 slice 指定的开始位置</li><li>长度，slice 的长度</li><li>最大长度，slice 开始位置到数组的最后位置的最大长度</li></ul></li><li><p>slice 几个有用的内置函数：</p><ul><li>len 获取 slice 的长度</li><li>cap 获取 slice 的最大容量</li><li>append 向 slice 里追加一个或多个元素，然后返回一个和 slice 一样类型的 slice<ul><li>append 函数会改变 slice 所引用的数组的内容，进而影响引用同一数组的其他 slice</li><li>当 slice 中无剩余空间（（cap-len）==0），将动态分配新的数组空间，返回的 slice 数组指针将指向这个空间，而原数组的内容将保持不变，其他引用此数组的 slice 不受影响</li></ul></li><li>copy 函数 copy 从源 slice 的 src 中复制元素到目标 dst，并返回复制的元素的个数</li></ul></li></ul></li><li><p>map</p><ul><li><p>格式：map[keyType]valueType</p></li><li><p>map 的读取和设置通过key来操作，同 slice 一样，区别是 slice 的 index 只能是 int 类型，而 map 类型很多，有 int ,string 及所有完全定了 == 与 != 操作的类型</p><pre><code>// 声明了一个 key 是字符串，值为 int 的字典，这种方式的声明需要在使用之前使用 make 初始化var  numbers  map[string] int </code></pre><pre><code>numbers := make(map[string]int) // 另一种 map 的声明方式numbers[&quot;one&quot;] = 1              // 赋值numbers[&quot;ten&quot;] = 10             // 赋值numbers[&quot;three&quot;] = 3            // 赋值fmt.Println(&quot;第三个数字是：&quot;，numbers[&quot;three&quot;]) // 读取数据，值为3</code></pre><p>注意点：</p><ul><li><p>map 是无序的，每次打印出来的 map 都会不一样，它不能通过 index 获取，必须通过 key 获取</p></li><li><p>map 长度是不固定的，是一种引用类型</p></li><li><p>内置的 len 函数同样适用于 map，返回 map 拥有的 key 的数量</p></li><li><p>map 的值很方便被修改：</p><ul><li><p>通过 numbers[“one”]=11 可以很容易的把 key 为 one 的字典值 改为11</p></li><li><p>map 的初始化可以通过 key:val 的方式初始化值</p></li><li><p>map 内置有判断是否存在 key 的方式通过 delete 删除 map 元素</p><pre><code>// 初始化一个字典rating := map[string]float32 {&quot;C&quot;:5, &quot;Go&quot;:4.5, &quot;Python&quot;:4.5, &quot;C++&quot;:2 } //map 有两个返回值，第二个返回值，如果不存在key，那么ok 为false，如果存在ok 为 truecsharpRating, ok := rating[&quot;C#&quot;]if ok {      fmt.Println(&quot;C# is in the map and its rating is &quot;, csharpRating) } else {       fmt.Println(&quot;We have no rating associated with C# in the map&quot;) } delete(rating, &quot;C&quot;) // 删除 key 为 C 的元素</code></pre><p>【这段代码有点似懂非懂，后面需要回溯】</p></li><li><p>如果两个 map 同时指向一个底层，那么一个改变，另一个随之改变</p><pre><code>m := make(map[string]string)m[&quot;Hello&quot;] = &quot;Bonjour&quot;m1 := mm1[&quot;Hello&quot;] = &quot;Salut&quot;  // m[&quot;Hello&quot;]发生改变，变成了 Salut</code></pre></li></ul></li></ul></li></ul></li><li><p>make 和 new</p><ul><li>make 用于内建类型（map、slice和channel）的内存分配<ul><li>内建函数 make(T, args) 只能创建 slice,map 和 channel，并返回一个<strong>有初始值（非零）</strong>的 T 类型，而不是 *T 。</li><li>本质来讲，导致这三个类型有所不同的原因是指向数据结构的引用再使用前必须被初始化<ul><li>例如，一个 slice ，是一个包含指向数据 （内部 array）的指针、长度和容量的三项描述符，在这些项目被初始化之前，slice 为 nil。</li><li>对于 slice,map,channel来说，make 初始化了内部的数据结构，填充适当的值</li></ul></li></ul></li><li>new 用于各种类型的内存分配<ul><li>内建函数 new(T) 分配了零值填充的 T 类型的内存空间，并且返回其地址，即一个 <em>T 类型的值，即它*</em>返回了一个指针**，指向新分配的类型 T 的零值</li></ul></li><li>【详细解释了 new 和 make 之间区别的图，需要回溯理解】</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;编译速度非常快，比C语言编译快&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;二十五个关键字有：&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Go学习" scheme="https://hellojw.github.io/categories/Go%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="技术" scheme="https://hellojw.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="编程" scheme="https://hellojw.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>章一Go环境变量</title>
    <link href="https://hellojw.github.io/2019/07/02/zhang-jie-yi-go-huan-jing-bian-liang/"/>
    <id>https://hellojw.github.io/2019/07/02/zhang-jie-yi-go-huan-jing-bian-liang/</id>
    <published>2019-07-02T11:34:47.000Z</published>
    <updated>2019-07-23T08:54:53.159Z</updated>
    
    <content type="html"><![CDATA[<p>整理了一份思维导图，便于理解书籍章节，如下所示：</p><p><img src="https://github.com/hellojw/hellojw.github.io/blob/master/images/Go%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.png" alt="Go环境配置"></p><p>额，很遗憾，我做了几次尝试，并没有解决插入图片的问题。</p><p><a href="https://www.cnblogs.com/WSQL/p/11232036.html" target="_blank" rel="noopener">所以图片可以通过我的博客园查看完整图片，单击此处获取我博客园关于本章节的地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;整理了一份思维导图，便于理解书籍章节，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/hellojw/hellojw.github.io/blob/master/images/Go%E7%8E%AF%E5%A2%83%E9%85%8D%E
      
    
    </summary>
    
      <category term="Go学习" scheme="https://hellojw.github.io/categories/Go%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="技术" scheme="https://hellojw.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="编程" scheme="https://hellojw.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Go学习开篇</title>
    <link href="https://hellojw.github.io/2019/07/01/go-xue-xi-ji-hua/"/>
    <id>https://hellojw.github.io/2019/07/01/go-xue-xi-ji-hua/</id>
    <published>2019-07-01T11:54:00.000Z</published>
    <updated>2019-07-23T02:56:19.152Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习-Go-目的"><a href="#学习-Go-目的" class="headerlink" title="学习 Go 目的"></a>学习 Go 目的</h2><ul><li>为了锻炼我的编程能力，能在我的github上多放点有价值的编程作品</li><li>为了提升自己的意志力和耐力</li><li>为了充实生活，不浪费光阴</li><li>突破自身瓶颈</li></ul><h2 id="学习-Go-途径"><a href="#学习-Go-途径" class="headerlink" title="学习 Go 途径"></a>学习 Go 途径</h2><ul><li>主要网站：Go 语言中文网</li><li>主要视频途径：Go 36 讲</li><li>主要依附书籍：该书籍是网络下载的，未注明作者和来源，PDF书名是go+web+编程，感觉书籍目录清晰，有利于学习层次的推进和助力</li></ul><h2 id="学习-Go-周期"><a href="#学习-Go-周期" class="headerlink" title="学习 Go 周期"></a>学习 Go 周期</h2><ul><li>2019年7月、8月、9月，熟练语法</li><li>2019年10月、11月、12月，找一个自己喜欢的项目，模仿编程</li><li>2020年1月、2月、3月、4月，项目实践，最终是让这个项目产生金钱效益</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;学习-Go-目的&quot;&gt;&lt;a href=&quot;#学习-Go-目的&quot; class=&quot;headerlink&quot; title=&quot;学习 Go 目的&quot;&gt;&lt;/a&gt;学习 Go 目的&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;为了锻炼我的编程能力，能在我的github上多放点有价值的编程作品&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="Go学习" scheme="https://hellojw.github.io/categories/Go%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="技术" scheme="https://hellojw.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="编程" scheme="https://hellojw.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>两天的技术小纪实</title>
    <link href="https://hellojw.github.io/2019/06/30/liang-tian-xiao-ji-shi/"/>
    <id>https://hellojw.github.io/2019/06/30/liang-tian-xiao-ji-shi/</id>
    <published>2019-06-30T10:54:00.000Z</published>
    <updated>2019-07-23T10:30:53.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="技术方面"><a href="#技术方面" class="headerlink" title="技术方面"></a>技术方面</h2><ol><li>更新方面</li></ol><ul><li>博客园更新了一下：运维面试相关的题目<br><a href="https://www.cnblogs.com/WSQL/articles/11106338.html" target="_blank" rel="noopener">https://www.cnblogs.com/WSQL/articles/11106338.html</a><ul><li>特别备注：<ul><li>只是想看看面试题目，有没有新变化，且更新的这份题目有点陈旧了</li><li>不要误会我要跳槽啊，啊啊啊，哈哈哈</li></ul></li><li><a href="https://hellojw.github.io/">https://hellojw.github.io/</a> 基地更新方面<ul><li>额，6月29号和6月30号未更新</li></ul></li></ul></li></ul><p>2.学习方面</p><ul><li>1).重新回顾了一下nginx的部分知识点（索引目录方面）<ul><li>1.nginx 开启目录，映射到服务器的指定目录，类似于简单的视频文件共享小站</li><li>2.基于1，想用fancy美化一下目录结构 <a href="https://github.com/aperezdc/ngx-fancyindex" target="_blank" rel="noopener">https://github.com/aperezdc/ngx-fancyindex</a></li></ul></li><li>2).部署了一套 olaindex 的 环境<ul><li>步骤：<a href="https://github.com/WangNingkai/OLAINDEX/blob/master/docs/install.md" target="_blank" rel="noopener">https://github.com/WangNingkai/OLAINDEX/blob/master/docs/install.md</a></li><li>按照以上的步骤，基本上是傻瓜化操作了，很顺利就部署好了</li></ul></li><li>3).学习了一下ifps星际大陆的，想用区块链的一些概念来部署一套实现文件共享和存储的环境<ul><li>可惜，ifps官网我打不开。。。暂时先留个底</li></ul></li><li>这1).2).3).的关联性：<ul><li>没有去搜索更多的文件共享或视频在线播放的信息，均基于以往的运维知识所想到的，同时也是能够解决相关人员的基本需求的，如果一个深入的调研，相信还会有别的方案。</li><li>星际大陆，是一个朋友在大数据公司工作，正好他们单位已经把这个ifps用于广告营销等数据方面了，好奇才想部署一套尝尝鲜的</li></ul></li><li>重新手写整理了一下linux 启动过程等知识，后续有时间要更新到网络上</li><li>关于沙箱方面，做了一个很肤浅的了解：<ul><li>因为2019年kubeCon大会，才注意到了gvisor这个概念</li><li>以前用过sandbox mysql，在docker中，从英文单词上，都是沙箱沙盒的意思，但是具体有什么关联性，区别性，想整体搞懂一下，并且重新看一下原来自己在docker写的sandbox知识点</li><li><a href="https://github.com/google/gvisor" target="_blank" rel="noopener">https://github.com/google/gvisor</a></li><li><a href="https://katacontainers.io/" target="_blank" rel="noopener">https://katacontainers.io/</a></li><li><a href="https://github.com/kata-containers/documentation/blob/master/design/architecture.md" target="_blank" rel="noopener">https://github.com/kata-containers/documentation/blob/master/design/architecture.md</a></li><li>以前也玩过 xen（生产环境）、做过xen服务器web应用和DB迁移到 exsi ,想重新梳理一下虚拟化的东西，包括容器方面的东西</li></ul></li><li>想梳理一下 linux 环境下，增加资源后，如果通过不重启的方式，热加载资源：<ul><li>比如 vm 中的虚拟机，我增加了一块100G盘，我可以通过echo “- - -“ &gt;/sys/class/scsi_host/hostxxx/scan的方式加载出磁盘信息，这是因为什么呢？？</li><li>还有没有其他场景呢？？</li></ul></li><li>关于zabbix监控这一块，把通知发送到企业微信群里，配置已完成，遗留问题：<ul><li>zabbix dashboard显示“已送达”，但是企业微信群里收不到信息，可手动触发脚本，是能够发送到企业微信中的</li></ul></li><li>关于 azkaban 任务调度监控：<ul><li>能够发送到企业微信里，每个flow的执行情况</li><li>如何把它接入到zabbix中？？</li></ul></li></ul><h2 id="其他方面"><a href="#其他方面" class="headerlink" title="其他方面"></a>其他方面</h2><ul><li>关注了一下上海周边的房价，年底要落实买房了，哈哈哈，我自己攒的首付哦，赞赞赞</li><li>跟朋友逛街了，第一次穿热裤和高跟出游，拍照发朋友圈，获赞使我的虚荣心得到满足，哈哈哈</li><li>跟朋友去电影院看了部恐怖电影“碟仙”，感觉还不错耶，喜欢黄奕</li><li>给我家的狗狗，豆豆小公举，洗了个澡澡，香香的</li><li>炖了乌鸡汤，哈哈哈，放了红枣、当归、党参、枸杞、黄芪、小土豆，可好喝了</li><li>追综艺“这就是街舞2”，超爱“易烊千玺”，所以优酷他的“长安十二时”，我也追了。。。</li></ul><hr><p>天哪。。所以时间不是很够。。。都用在哪里去了呢。。。反思反思。。。后面还有很多事情要做呀</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;技术方面&quot;&gt;&lt;a href=&quot;#技术方面&quot; class=&quot;headerlink&quot; title=&quot;技术方面&quot;&gt;&lt;/a&gt;技术方面&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;更新方面&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;博客园更新了一下：运维面试相关的题目&lt;br&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="杂七杂八的总结" scheme="https://hellojw.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="情感" scheme="https://hellojw.github.io/tags/%E6%83%85%E6%84%9F/"/>
    
      <category term="生活" scheme="https://hellojw.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
</feed>
